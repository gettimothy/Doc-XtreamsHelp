*  Xtreams [XtreamsHelp]** Todo#+BEGIN_EXAMPLE  create a very simple example that changes foo to bar.  explain how tests are essential in developing a grammar.    #+END_EXAMPLE**  Introduction #+BEGIN_EXAMPLE Xtreams resides at http://www.squeaksource.com/Xtreams that page points to: https://code.google.com/archive/p/xtreams/  and from there: https://www.cincomsmalltalk.com/main/?s=XtreamsThese are working notes as I teach myself the PEG parser side of things. #+END_EXAMPLE**  Xtreams Parsing #+BEGIN_EXAMPLE  Xtreams-parsing is an implementation of Prof. Bryan Ford's Parser Expression Grammar   https://bford.info/pub/lang/peg/...				The main players are: Actor, Parser, Grammar....				The Actor allows "callbacks" upon a match on a rule  invoking it.				Pragmas within a callback are used to associate a Rule with that callback.				#+END_EXAMPLE** The PEG grammar#+BEGIN_EXAMPLEThe PEG grammar resides on the class side of PEGParser.It serves as a useful model in developing your own grammar.It defines what a PEG grammar is .Here a Grammar (the top rule) is One or More Definitions followed by end of input.grammarPEG    ^'Grammar			<-	Definition+ !.    Definition			<-	s Identifier s (ASSIGN / DefinitionError) s Expression s    DefinitionError		<-	(!S .)*    Expression			<-	Sequence ((SLASH s Sequence) / (SequenceError s))*    Sequence			<-	Node+    SequenceError		<-	SLASH    Node			<-	Prefix? Primary Suffix? s    /	!SLASH !(Identifier s ASSIGN) !CLOSE_PAREN !CLOSE_BRACE NodeError s    NodeError			<-	.    Primary			<-	Reference / Group / Literal / Range / DOT    Reference			<-	Identifier s !ASSIGN    Group			<-	OPEN_PAREN s Expression s CLOSE_PAREN    Prefix			<-	AND / NOT    Suffix			<-	Cardinality / QUESTION / STAR / PLUS    Literal			<-	QUOTE LiteralEntity{QUOTE}  /	DOUBLE_QUOTE LiteralEntity{DOUBLE_QUOTE}    LiteralEntity		<-	Escape / .    Range			<-	OPEN_BRACKET s "^"? RangeSet{1,CLOSE_BRACKET}    RangeSet			<-	s LiteralEntity DASH LiteralEntity s   /	s LiteralEntity s    Cardinality			<-	OPEN_BRACE s (CardinalityRange / CardinalityLoopMin / CardinalityRangeMin / CardinalityLoop) s CLOSE_BRACE    CardinalityRangeMin	        <-	NumLiteral    CardinalityRange	        <-	NumLiteral s COMMA s NumLiteral    CardinalityLoopMin	        <-	NumLiteral s COMMA s Expression    CardinalityLoop		<-	Expression    Identifier			<-	[a-zA-Z_] [a-zA-Z0-9_]*    NumLiteral			<-	"Infinity" / "0" / [1-9] [0-9]*    Escape			<-	BACKSLASH [x] [0-9A-F]{6}   /	BACKSLASH [nrts\-\\\[\]\''\"]/	EscapeError    EscapeError			<-	BACKSLASH .    s				<-	S*    S				<-	whitespace+					    /	comment    comment			<-	OPEN_COMMENT comment_body{CLOSE_COMMENT}    comment_body		<-	comment					    /	.    whitespace			<-	[\s\t\n\r]    ASSIGN			<-	"<-"    SLASH			<-	"/"    BACKSLASH		        <-	"\\"    AND				<-	"&"    NOT				<-	"!"    COMMA			<-	","    QUESTION			<-	"?"    STAR			<-	"*"    PLUS			<-	"+"    DASH			<-	"-"    DOT				<-	"."    QUOTE			<-	"''"    DOUBLE_QUOTE	        <-	''"''    OPEN_BRACKET	        <-	"["    CLOSE_BRACKET	        <-	"]"    OPEN_PAREN		        <-	"("    CLOSE_PAREN		        <-	")"    OPEN_BRACE		        <-	"{"    CLOSE_BRACE		        <-	"}"    OPEN_COMMENT	        <-	"/*"    CLOSE_COMMENT	        <-	"*/"' Other grammars are on the class as well.#+END_EXAMPLE**  PEGGenerators #+BEGIN_EXAMPLEThe PEGxGenerator has an 'actor' variable which is a Dictionary who's keys are the Rules in the grammar.#+END_EXAMPLE** A Simple Example#+BEGIN_EXAMPLE  todo: create a very simple grammar and callback .#+END_EXAMPLE**  Xtreams Parsing Rules  #+BEGIN_EXAMPLE    XTreams    https://code.google.com/archive/p/xtreams/wikis/Parsing.wiki     https://nim-lang.org/docs/pegs.html    A  < - E      Rule:     Bind the expression  E  to the nonterminal symbol  A .    Left recursive rules are not possible and crash the matching engine.    \ddd      Character with decimal code ddd    \" , etc     Literal  " , etc.     PEG: Literal				<-	QUOTE LiteralEntity{QUOTE}/	DOUBLE_QUOTE LiteralEntity{DOUBLE_QUOTE}    A ... Z      Sequence:     Apply expressions  A , ...,  Z , in this order, to consume consecutive portions of the text ahead, as long as they succeed.     Indicate success if all succeeded.     Otherwise do not consume any text and indicate failure.     The sequence's precedence is higher than that of Ordered Choice:  A B / C  means  (A B) / Z  and not  A (B / Z) .     A / ... / Z      Ordered Choice:     Apply expressions  A , ...,  Z , in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded.     Otherwise do not consume any text and indicate failure.     The Ordered Choice precedence is lower than that of Sequence:  A B / C  means  (A B) / Z  and not  A (B / Z) .     (E)      Grouping:     Parenthesis can be used to change operator priority.     (A B) / Z  vs.  A (B / Z) .     {E}         Cardinality:  Stop Expression    A <- B{C}     to accept A,  means, accept any number of B up until E comes.     Consume E too, but don't yield it.     So, such expression accepts: BE, BBE, BBBE, BBBBE, etc, and yields B, BB, BBB, BBBB, etc.    A <- B{1,"\n"}    means that a A consists of one or more Bs.     The parser will  read B's up until "\n" appears on the stream, which is a carriage return    character.    E?    Cardinality:	    Zero or One  E    E*      Cardinality    Zero or more: E    Apply expression  E  repeatedly to match the text ahead, as long as it succeeds.     Consume the matched text (if any).     Always indicate success.     E*	    Cardinality:	    Matches zero or more E.    E+	    Cardinality:		    Matches one or more E    Apply expression  E  repeatedly to match the text ahead, as long as it succeeds.     Consume the matched text (if any) and indicate success if there was at least one match.     Otherwise indicate failure.     E{m}    Cardinality:		    Matches m repetitions of E.    B{3}, which is a shorthand for BBB.	    B{E} means, accept any number of B up until E comes.     Consume E too, but don't yield it.     So, such expression accepts: BE, BBE, BBBE, BBBBE, etc, and yields B, BB, BBB, BBBB, etc.    E{m,n}	    Cardinality:		    Matches from m to n repetitions of E.    B{1,3} means B 1 to 3 times, so it accepts B, BB, and BBB.    [A-Za-z]+	    Cardinality:			    EXAMPLE: Matches one or more alphabetical characters.    $      Anchor:     Matches at the end of the input.     No character is consumed. Same as  !. .     !. = $    Anchor:     Matches at the end of the input.     No character is consumed. Same as  $    ^      Anchor: Matches at the start of the input.     No character is consumed.     &E      And predicate:     Indicate success if expression  E  matches the text ahead;    otherwise indicate failure.     Do not consume any text.     !E      Not predicate:     Indicate failure if expression E matches the text ahead;     otherwise indicate success.     Do not consume any text.     [s]      Character class:     If the character ahead appears in the string  s , consume it and indicate success.     Otherwise indicate failure.     [a-b]      Character range:     If the character ahead is one from the range  a  through  b , consume it and indicate success.     Otherwise indicate failure.     's'      String:     If the text ahead is the string  s , consume it and indicate success.     Otherwise indicate failure.     .      Any character:     If there is a character ahead, consume it and indicate success.     Otherwise (that is, at the end of input) indicate failure.     "BELOW PROBABLY NOT IN PEG"    _      Any Unicode character:     If there is an UTF-8 character ahead, consume it and indicate success.     Otherwise indicate failure.     @E      Search:     Shorthand for  (!E .)* E .     (Search loop for the pattern  E .)     {@} E      Captured Search:     Shorthand for  {(!E .)*} E .     (Search loop for the pattern  E .) Everything until and exluding  E  is captured.     @@ E      Same as  {@} E .     \identifier      Built-in macro for a longer expression.     $i      Back reference to the  i th capture.  i  counts from 1.     i's'      String match ignoring case.     y's'      String match ignoring style.     v's'      Verbatim string match: Use this to override a global  \i  or  \y  modifier.     i$j      String match ignoring case for back reference.     y$j      String match ignoring style for back reference.     v$j      Verbatim string match for back reference. #+END_EXAMPLE